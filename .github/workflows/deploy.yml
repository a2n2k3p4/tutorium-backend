name: Docker Compose (Server)

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

# Default token only needs read
permissions:
  contents: read

jobs:
  deploy:
    name: Deploy to Server
    # Skip fork PRs to avoid secret access issues
    if: github.event_name == 'push' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Copy project files to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.PORT }}
          source: ".,!.git"
          target: "~/tutorium-backend"
          rm: true

      - name: Deploy with docker compose
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.PORT }}
          script: |
            bash -lc '
              set -e

              # Change to project directory
              cd ~/tutorium-backend

              echo "=== Starting deployment ==="
              echo "Current directory: $(pwd)"

              # Create .env file on the server (needed for docker-compose)
              echo "=== Creating .env file for docker-compose ==="
              # Use a persistent server-side env file for production secrets
              ENV_FILE=~/secrets/tutorium-backend.env
              mkdir -p "$(dirname "$ENV_FILE")"
              if [ -f "$ENV_FILE" ]; then
                  cp $ENV_FILE .env
                  echo "ℹ️ Using env file: $ENV_FILE"
              else
                  echo "❌ $ENV_FILE not found!"
                  ls -la
                  exit 1
              fi

              # Create compose file on the server (needed for docker-compose)
              echo "=== Creating compose file for docker-compose ==="
              # Use a persistent server-side compose file for production secrets
              COMPOSE_FILE=~/secrets/tutorium-backend.compose.yaml
              mkdir -p "$(dirname "$COMPOSE_FILE")"
              if [ -f "$COMPOSE_FILE" ]; then
                  cp $COMPOSE_FILE compose.yaml
                  echo "ℹ️ Using compose file: $COMPOSE_FILE"
              else
                  echo "❌ $COMPOSE_FILE not found!"
                  ls -la
                  exit 1
              fi

              # Check if docker and docker compose are available
              if ! command -v docker &> /dev/null; then
                  echo "ERROR: Docker is not installed on the server"
                  exit 1
              fi

              # Check docker compose command (newer versions use '"'"'docker compose'"'"', older use '"'"'docker-compose'"'"')
              if docker compose version &> /dev/null; then
                  DOCKER_COMPOSE="docker compose"
              elif command -v docker-compose &> /dev/null; then
                  DOCKER_COMPOSE="docker-compose"
              else
                  echo "ERROR: Docker Compose is not installed on the server"
                  exit 1
              fi

              echo "Using: $DOCKER_COMPOSE"

              # Stop existing containers (ignore errors if no containers are running)
              echo "=== Stopping existing containers ==="
              $DOCKER_COMPOSE down --remove-orphans || echo "No existing containers to stop"

              # Remove old images to ensure fresh build
              echo "=== Cleaning up old images ==="
              docker image prune -f || true

              # Pull latest base images
              echo "=== Pulling latest base images ==="
              $DOCKER_COMPOSE pull || echo "Some images couldn'"'"'t be pulled, will build anyway"

              # Build new images
              echo "=== Building application ==="
              $DOCKER_COMPOSE build --no-cache --pull

              # Start services
              echo "=== Starting services ==="
              $DOCKER_COMPOSE up -d --remove-orphans

              # Wait a moment for services to start
              sleep 10

              # Check container status
              echo "=== Container status ==="
              $DOCKER_COMPOSE ps

              # Check if Go app is healthy
              echo "=== Checking application health ==="
              if $DOCKER_COMPOSE ps | grep -q "go_app.*Up"; then
                  echo "✅ Go application is running"
              else
                  echo "❌ Go application failed to start"
                  echo "=== Application logs ==="
                  $DOCKER_COMPOSE logs go_app
                  exit 1
              fi

              # Check if PostgreSQL is healthy
              if $DOCKER_COMPOSE ps | grep -q "postgres.*Up.*healthy"; then
                  echo "✅ PostgreSQL is running and healthy"
              else
                  echo "❌ PostgreSQL is not healthy"
                  echo "=== PostgreSQL logs ==="
                  $DOCKER_COMPOSE logs postgres
                  exit 1
              fi

              echo "=== Deployment completed successfully ==="
              echo "Application should be available on port 8000"
              echo "Database migrations will run automatically when the Go app starts"
            '
