name: Deploy

on:
  push:
    branches:
      - "main"
  pull_request:
    branches:
      - "main"

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    # Skip fork PRs to avoid secret access issues
    if: github.event_name == 'push' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Copy project files to server
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.PORT }}
          source: "./"
          target: "~/tutorium-backend"
          overwrite: true
          strip_components: 0

      - name: Deploy with docker compose
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.PORT }}
          script: |
            set -e

            # Change to project directory
            cd ~/tutorium-backend

            echo "=== Starting deployment ==="
            echo "Current directory: $(pwd)"

            # Check if docker and docker compose are available
            if ! command -v docker &> /dev/null; then
                echo "ERROR: Docker is not installed on the server"
                exit 1
            fi

            # Check docker compose command (newer versions use 'docker compose', older use 'docker-compose')
            if docker compose version &> /dev/null; then
                DOCKER_COMPOSE="docker compose"
            elif command -v docker-compose &> /dev/null; then
                DOCKER_COMPOSE="docker-compose"
            else
                echo "ERROR: Docker Compose is not installed on the server"
                exit 1
            fi

            echo "Using: $DOCKER_COMPOSE"

            # Stop existing containers (ignore errors if no containers are running)
            echo "=== Stopping existing containers ==="
            $DOCKER_COMPOSE down --remove-orphans || echo "No existing containers to stop"

            # Remove old images to ensure fresh build
            echo "=== Cleaning up old images ==="
            docker image prune -f || true

            # Pull latest base images
            echo "=== Pulling latest base images ==="
            $DOCKER_COMPOSE pull || echo "Some images couldn't be pulled, will build anyway"

            # Build new images
            echo "=== Building application ==="
            $DOCKER_COMPOSE build --no-cache --pull

            # Start services
            echo "=== Starting services ==="
            $DOCKER_COMPOSE up -d --remove-orphans

            # Wait a moment for services to start
            sleep 10

            # Check container status
            echo "=== Container status ==="
            $DOCKER_COMPOSE ps

            # Check if Go app is healthy
            echo "=== Checking application health ==="
            if $DOCKER_COMPOSE ps | grep -q "go_app.*Up"; then
                echo "✅ Go application is running"
            else
                echo "❌ Go application failed to start"
                echo "=== Application logs ==="
                $DOCKER_COMPOSE logs go_app
                exit 1
            fi

            # Check if PostgreSQL is healthy
            if $DOCKER_COMPOSE ps | grep -q "postgres.*Up.*healthy"; then
                echo "✅ PostgreSQL is running and healthy"
            else
                echo "❌ PostgreSQL is not healthy"
                echo "=== PostgreSQL logs ==="
                $DOCKER_COMPOSE logs postgres
                exit 1
            fi

            echo "=== Deployment completed successfully ==="
            echo "Application should be available on port 8000"
            echo "Database migrations will run automatically when the Go app starts"
